<!DOCTYPE html>
<html>
<head>
<title>Graph demo</title>
</head>
<body>

<canvas id="port" style="border:1px solid #000000;">
</canvas>

<script>
// Window-specific inits
var canvas = document.getElementById("port");
canvas.width  = 400;
canvas.height = 400;
var ctx = canvas.getContext("2d");


var NODE_COUNT = 30;
var RADIUS = 180; // max radius of circle containing all the nodes

/*
	G - a graph representation.
	G is an array of Vertice objects, which have following attributes:
	_x, _y - coordinates on a plane,
	adj - adjacency array (unsorted).
*/
var G = [];

/*
	The working graph has NODE_COUNT vertices.
	All of them lie within a defined circle,and the density decreases
	with distance from the center
*/
for (var i=0; i<NODE_COUNT; i++) {
	r = Math.random()*RADIUS;
	fi = Math.random()*6.283;

	addVertex(200 + r * Math.cos(fi),
						200 + r * Math.sin(fi));
}
var superv = []; // Super-triangle necessary for the algorithm
superv[0] = addVertex (200 + 0           , 200 + 2   * RADIUS);
superv[1] = addVertex (200 + 2.5 * RADIUS, 200 - 1.2 * RADIUS);
superv[2] = addVertex (200 - 2.5 * RADIUS, 200 - 1.2 * RADIUS);
addEdge (NODE_COUNT  , NODE_COUNT+1);
addEdge (NODE_COUNT  , NODE_COUNT+2);
addEdge (NODE_COUNT+1, NODE_COUNT+2);

/*
	Puts all the edges, producing a full graph.
*/
for (var i=0; i<NODE_COUNT; i++) {
	for (var j=i+1; j<NODE_COUNT; j++) {
		addEdge(i,j);
	}
}

drawGraph();

// Adds vertex. Returns index of the new vertex
function addVertex(x,y) {
	var ret;
	ret = G.push({
		_x: x,
		_y: y,
		adj: []
	});
	return ret-1;
}

function addEdge(a,b) {
	if(G[a].adj.indexOf(b) == -1)
		G[a].adj.push(b);
	if(G[b].adj.indexOf(a) == -1)
		G[b].adj.push(a);
}

// Returns TRUE iff there is an egde between a and b
function checkForEdge(a,b) {
	return (G[a].adj.indexOf(b) != -1);
}

function drawEdge(a,b) {
	ctx.moveTo(G[a]._x, G[a]._y);
	ctx.lineTo(G[b]._x, G[b]._y);
	ctx.stroke();
	console.log("Drawing",a,b);
}

function drawGraph() {
	// Draws nodes
	for (i in G) {
		ctx.beginPath();
		ctx.arc(G[i]._x, G[i]._y, 3, 0, 2*Math.PI);
		ctx.stroke();
	}

	// Draws edges
	var ai = 0;
	function asyncChunk() {
		// At a time, edges adjacent to a single node are drawn
		console.log(ai, G[ai].adj);
		for (j in G[ai].adj) {
			drawEdge(ai,G[ai].adj[j]);
		}
		ai++;
		if (ai < G.length) {
			setTimeout(asyncChunk, 1);
		}
	}
	asyncChunk();

}

</script>

</body>
</html>
