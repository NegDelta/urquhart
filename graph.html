<!DOCTYPE html>
<html>
<head>
<title>Graph demo</title>
</head>
<body>

<canvas id="port" style="border:1px solid #000000;">
</canvas>

<script>
// Window-specific inits
var canvas = document.getElementById("port");
canvas.width  = 400;
canvas.height = 400;
var ctx = canvas.getContext("2d");


var NODE_COUNT = 30;
var RADIUS = 180; // max radius of circle containing all the nodes

/*
	G - a graph representation.
	G is an array of Vertice objects, which have following attributes:
	_x, _y - coordinates on a plane,
	adj - adjacency array (unsorted).
*/
var G = [];

/*
	The working graph has NODE_COUNT vertices.
	All of them lie within a defined circle,and the density decreases
	with distance from the center
*/
for (var i=0; i<NODE_COUNT; i++) {
	r = Math.random()*RADIUS;
	fi = Math.random()*6.283;

	addVertex(200 + r * Math.cos(fi),
						200 + r * Math.sin(fi));
}

// Triangle set. Vertices are represented by their index.
var Trg = [];

drawGraph();
delaunay();

/*
	Constructs the Delaunay triangulation for the set of vertices
	using the Bowyer-Watson algorithm.
*/
function delaunay() {
	var superv = []; // Add super-triangle necessary for the algorithm
	superv[0] = addVertex (200 + 0           , 200 + 2   * RADIUS);
	superv[1] = addVertex (200 + 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	superv[2] = addVertex (200 - 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	addEdge (NODE_COUNT  , NODE_COUNT+1);
	addEdge (NODE_COUNT  , NODE_COUNT+2);
	addEdge (NODE_COUNT+1, NODE_COUNT+2);
	addTriangle (NODE_COUNT, NODE_COUNT+1, NODE_COUNT+2);

	var EBuf = []; // stores edges of 'bad' triangles
	var VBuf = []; // stores vertices of resulting polygonal hole

	for (var i=0; i<NODE_COUNT; i++) { // for every vertex
		console.log("i",i,"Trg is ",Trg);
		EBuf = []; VBuf = [];
		for (var j=0; j<Trg.length; j++) { // for every triangle
			if (isInCircle(i,j)) {
				toggleEBuf(Trg[j].v[0], Trg[j].v[1]); // add the triangle edges to the edge buffer
				toggleEBuf(Trg[j].v[0], Trg[j].v[2]);
				toggleEBuf(Trg[j].v[1], Trg[j].v[2]);

				Trg.splice(j,1); // remove triangle from list
				j--;
			}
		}

		// add triangles w/ edges from the processed vertex
		for (var j=0; j<EBuf.length; j++) {
			addTriangle(EBuf[j][0], EBuf[j][1], i);
		}


		// Adds edge to buffer, or deletes it if it's already there
		function toggleEBuf(a,b) {
			var edge = [a,b];
			edge.sort(); // ensures uniqueness - necessary unlike in adj table

			if(EBuf.indexOf(edge) == -1) { // edge not yet in EBuf
				EBuf.push(edge);
			} else { // edge already in EBuf, therefore adjacent to two badtriangles and not a part of triangulation
				EBuf.splice(EBuf.indexOf(edge),1);
				// delete from working graph too
				G[a].adj.splice(G[a].adj.indexOf(b),1);
				G[b].adj.splice(G[b].adj.indexOf(a),1);
			}
		}
	}
}


/*
	Checks whether given point is inside the triangle's circumcircle
	a,t - indices in respective sets
*/
function isInCircle(a,t) {
	var distx = G[a]._x - Trg[t].centerx;
	var disty = G[a]._y - Trg[t].centery;
	var ret = (distx*distx + disty*disty) < Trg[t].crad2;
	if (ret) {
		console.log("in circle: ",a, distx*distx + disty*disty,"in",t,Trg[t].crad2);
	}
	return ret;
}

// Adds vertex. Returns index of the new vertex
function addVertex(x,y) {
	var ret;
	ret = G.push({
		_x: x,
		_y: y,
		adj: []
	});
	return ret-1;
}

function addEdge(a,b) {
	if(G[a].adj.indexOf(b) == -1)
		G[a].adj.push(b);
	if(G[b].adj.indexOf(a) == -1)
		G[b].adj.push(a);
}

// Adds a triangle of given vertices to the set
function addTriangle(a,b,c) {
	var sorter = [a,b,c];
	sorter.sort();
	var bx = G[b]._x - G[a]._x;
	var by = G[b]._y - G[a]._y;
	var cx = G[c]._x - G[a]._x;
	var cy = G[c]._y - G[a]._y;
	var rad = 2 * (bx*cy - by*cx);
	Trg.push({
		v: sorter,
		centerx: (cy*(bx*bx + by*by) - by*(cx*cx + cy*cy)) / rad + G[a]._x,
		centery: (bx*(cx*cx + cy*cy) - cx*(bx*bx + by*by)) / rad + G[a]._y,
		crad2: bx*bx + by*by
			// squared! there's no point in calculating sqrt twice while comparing
	});
}

// Returns TRUE iff there is an edge between a and b
function isAdjacent(a,b) {
	return (G[a].adj.indexOf(b) != -1);
}

function drawEdge(a,b) {
	ctx.moveTo(G[a]._x, G[a]._y);
	ctx.lineTo(G[b]._x, G[b]._y);
	ctx.stroke();
}

function drawGraph() {
	// TODO: Clear canvas

	// Draws nodes
	for (var i=0; i<G.length; i++) {
		ctx.beginPath();
		ctx.arc(G[i]._x, G[i]._y, 3, 0, 2*Math.PI);
		ctx.stroke();
	}

	// Draws edges
	var ai = 0;
	function asyncChunk() {
		// At a time, edges adjacent to a single node are drawn
		for (var j=0; j<G[ai].adj.length; j++) {
			drawEdge(ai,G[ai].adj[j]);
		}
		ai++;
		if (ai < G.length) {
			setTimeout(asyncChunk, 1);
		}
	}
	asyncChunk();

}

</script>

</body>
</html>
