<!DOCTYPE html>
<html>
<head>
<title>Graph demo</title>
</head>
<body>

<canvas id="port" style="border:1px solid #000000;">
</canvas>

<script>
// Window-specific inits
var canvas = document.getElementById("port");
canvas.width  = 400;
canvas.height = 400;
var ctx = canvas.getContext("2d");


var NODE_COUNT = 30;
var RADIUS = 180; // max radius of circle containing all the nodes

/*
	G - a graph representation.
	G is an array of Vertice objects, which have following attributes:
	_x, _y - coordinates on a plane,
	adj - adjacency array (unsorted).
*/
var G = [];

/*
	The working graph has NODE_COUNT vertices.
	All of them lie within a defined circle,and the density decreases
	with distance from the center
*/
for (var i=0; i<NODE_COUNT; i++) {
	r = Math.random()*RADIUS;
	fi = Math.random()*6.283;

	addVertex(200 + r * Math.cos(fi),
						200 + r * Math.sin(fi));
}

// Triangle set. A triangle is represented as an ordered set of 3 vertices.
// Vertices are represented by their index.
var Trg = [];

drawGraph();
delaunay();

/*
	Constructs the Delaunay triangulation for the set of vertices
	using the Bowyer-Watson algorithm.
*/
function delaunay() {
	var superv = []; // Add super-triangle necessary for the algorithm
	superv[0] = addVertex (200 + 0           , 200 + 2   * RADIUS);
	superv[1] = addVertex (200 + 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	superv[2] = addVertex (200 - 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	addEdge (NODE_COUNT  , NODE_COUNT+1);
	addEdge (NODE_COUNT  , NODE_COUNT+2);
	addEdge (NODE_COUNT+1, NODE_COUNT+2);
	addTriangle (NODE_COUNT, NODE_COUNT+1, NODE_COUNT+2);

	// Stores edges that may be removed after each search for 'bad' triangles
	var EBuf;

	for (var i=0; i<NODE_COUNT; i++) {
		console.log("i",i,"Trg is ",Trg);
		EBuf = [];
		for (var j=0; j<Trg.length; j++) {
			if (isInCircle(i,j)) {
				EBuf.push(Trg[j][0]); // TODO: if alread exists, delete from EBuf
				EBuf.push(Trg[j][1]); // instead of adding a second one
				EBuf.push(Trg[j][2]);

				Trg.splice(j,1);
				j--;
			}
		}
		EBuf.sort();
		/*
			TODO: Add vertex to triangulation like in following pseudocode
			//initialize the edge buffer
			for each triangle currently in the triangle list
				 calculate the triangle circumcircle center and radius
				 if the point lies in the triangle circumcircle then
						add the three triangle edges to the edge buffer
						remove the triangle from the triangle list
				 endif
			endfor
			delete all doubly specified edges from the edge buffer
				 this leaves the edges of the enclosing polygon only
			add to the triangle list all triangles formed between the point
				 and the edges of the enclosing polygon
		*/
	}
}

// Adds edge to buffer, or deletes it if it's already there
function toggleEBuf(a) {
	// TODO
}

/*
	Checks whether given point is inside the triangle's circumcircle
	a,t - indicces in respective sets
*/
function isInCircle(a,t) {
	var distx = G[a]._x - Trg[t].centerx;
	var disty = G[a]._y - Trg[t].centery;
	var ret = (distx*distx + disty*disty) < Trg[t].crad2;
	if (ret) {
		console.log("in circle: ",a, distx*distx + disty*disty,"in",t,Trg[t].crad2);
	}
	return ret;
}

// Adds vertex. Returns index of the new vertex
function addVertex(x,y) {
	var ret;
	ret = G.push({
		_x: x,
		_y: y,
		adj: []
	});
	return ret-1;
}

function addEdge(a,b) {
	if(G[a].adj.indexOf(b) == -1)
		G[a].adj.push(b);
	if(G[b].adj.indexOf(a) == -1)
		G[b].adj.push(a);
}

// Adds a triangle of given vertices to the set
function addTriangle(a,b,c) {
	var sorter = [a,b,c];
	sorter.sort();
	var bx = G[b]._x - G[a]._x;
	var by = G[b]._y - G[a]._y;
	var cx = G[c]._x - G[a]._x;
	var cy = G[c]._y - G[a]._y;
	var rad = 2 * (bx*cy - by*cx);
	Trg.push({
		v: sorter,
		centerx: (cy*(bx*bx + by*by) - by*(cx*cx + cy*cy)) / rad + G[a]._x,
		centery: (bx*(cx*cx + cy*cy) - cx*(bx*bx + by*by)) / rad + G[a]._y,
		crad2: bx*bx + by*by
			// squared! there's no point in calculating sqrt twice while comparing
	});
}

// Returns TRUE iff there is an edge between a and b
function isAdjacent(a,b) {
	return (G[a].adj.indexOf(b) != -1);
}

function drawEdge(a,b) {
	ctx.moveTo(G[a]._x, G[a]._y);
	ctx.lineTo(G[b]._x, G[b]._y);
	ctx.stroke();
}

function drawGraph() {
	// Draws nodes
	for (var i=0; i<G.length; i++) {
		ctx.beginPath();
		ctx.arc(G[i]._x, G[i]._y, 3, 0, 2*Math.PI);
		ctx.stroke();
	}

	// Draws edges
	var ai = 0;
	function asyncChunk() {
		// At a time, edges adjacent to a single node are drawn
		for (var j=0; j<G[ai].adj.length; j++) {
			drawEdge(ai,G[ai].adj[j]);
		}
		ai++;
		if (ai < G.length) {
			setTimeout(asyncChunk, 1);
		}
	}
	asyncChunk();

}

</script>

</body>
</html>
