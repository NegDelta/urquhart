<!DOCTYPE html>
<html>
<head>
<title>Graph demo</title>
</head>
<body>

<canvas id="port" style="border:1px solid #000000;">
</canvas>

<script>
// Window-specific inits
var canvas = document.getElementById("port");
canvas.width  = 400;
canvas.height = 400;
var ctx = canvas.getContext("2d");


var NODE_COUNT = 30;
var RADIUS = 180; // max radius of circle containing all the nodes

/*
	G - a graph representation.
	G is an array of Vertice objects, which have following attributes:
	_x, _y - coordinates on a plane,
	adj - adjacency array (unsorted).
*/
var G = [];

/*
	The working graph has NODE_COUNT vertices.
	All of them lie within a defined circle,and the density decreases
	with distance from the center
*/
for (var i=0; i<NODE_COUNT; i++) {
	r = Math.random()*RADIUS;
	fi = Math.random()*6.283;

	addVertex(200 + r * Math.cos(fi),
						200 + r * Math.sin(fi));
}

	// TODO: Initialize triangle set. It will be useful throughout the execution

drawGraph();

/*
	Constructs the Delaunay triangulation for the set of vertices
	using the Bowyer-Watson algorithm.
*/
function delaunay() {
	var superv = []; // Add super-triangle necessary for the algorithm
	superv[0] = addVertex (200 + 0           , 200 + 2   * RADIUS);
	superv[1] = addVertex (200 + 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	superv[2] = addVertex (200 - 2.5 * RADIUS, 200 - 1.2 * RADIUS);
	addEdge (NODE_COUNT  , NODE_COUNT+1);
	addEdge (NODE_COUNT  , NODE_COUNT+2);
	addEdge (NODE_COUNT+1, NODE_COUNT+2);

	for (var i=0; i<NODE_COUNT; i++) {
		/*
			TODO: Add vertice to triangulation like in following pseudocode
			initialize the edge buffer
			for each triangle currently in the triangle list
				 calculate the triangle circumcircle center and radius
				 if the point lies in the triangle circumcircle then
						add the three triangle edges to the edge buffer
						remove the triangle from the triangle list
				 endif
			endfor
			delete all doubly specified edges from the edge buffer
				 this leaves the edges of the enclosing polygon only
			add to the triangle list all triangles formed between the point
				 and the edges of the enclosing polygon
		*/
	}
}

// Adds vertex. Returns index of the new vertex
function addVertex(x,y) {
	var ret;
	ret = G.push({
		_x: x,
		_y: y,
		adj: []
	});
	return ret-1;
}

function addEdge(a,b) {
	if(G[a].adj.indexOf(b) == -1)
		G[a].adj.push(b);
	if(G[b].adj.indexOf(a) == -1)
		G[b].adj.push(a);
}

// Returns TRUE iff there is an egde between a and b
function checkForEdge(a,b) {
	return (G[a].adj.indexOf(b) != -1);
}

function drawEdge(a,b) {
	ctx.moveTo(G[a]._x, G[a]._y);
	ctx.lineTo(G[b]._x, G[b]._y);
	ctx.stroke();
	console.log("Drawing",a,b);
}

function drawGraph() {
	// Draws nodes
	for (i in G) {
		ctx.beginPath();
		ctx.arc(G[i]._x, G[i]._y, 3, 0, 2*Math.PI);
		ctx.stroke();
	}

	// Draws edges
	var ai = 0;
	function asyncChunk() {
		// At a time, edges adjacent to a single node are drawn
		console.log(ai, G[ai].adj);
		for (j in G[ai].adj) {
			drawEdge(ai,G[ai].adj[j]);
		}
		ai++;
		if (ai < G.length) {
			setTimeout(asyncChunk, 1);
		}
	}
	asyncChunk();

}

</script>

</body>
</html>
